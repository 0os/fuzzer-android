#!/usr/bin/python

import sys
import os
from lexer import *
from string import *

# Build the lexer
lexer = lex.lex()

primitive = [
  ["uint32_t"],
  ["int32_t"],
  ["int"],
  ["char"],
  ["unsigned int"],
  ["unsigned long"],
  ["size_t"]
]


def isPrimitive(name):
  for i in primitive:
    if i[0] == name:
      return True

  return False


# Open files to be read/writen
#file0 = open("manual_types","r")
file1 = open("ioctl_types.h","r")
file2 = open("fuzz_ioctl_struct.c","w")
file3 = open("struct_type_enum","w")

tokens1 = []
tokens2 = []
type_list = []
struct_list = []
# Tokenize the source list of structs
for line in file1.readlines():
  lexer.input(line)
  while True:
    tok = lexer.token()
    if not tok: break      
    tokens1.append(tok)

tokens2 = list(tokens1)

last = None
k = 0
l = []
b = False
for i in tokens2:
  if i.type == "STRUCT" and tokens2[k+2].type == "OPEN":
    #type_list.append(tokens2[k+1].value)
    last = tokens2[k+1].value
    struct_list.append(tokens2[k+1].value)

  elif i.type == "OPEN":
    b = True
    k = k + 1
    continue

  elif i.type == "CLOSE":
    
    type_list.append((last,l))
    b = False
    l = []
    k = k + 1
    continue

  if b == True:
    l.append(i)

  k = k + 1



k = 0
for i in tokens2:
  if i.type == "STRUCT" and tokens2[k+1].type != "OPEN" and tokens2[k+2].type != "OPEN":
     if tokens2[k+1].value not in struct_list:
       print "WARNING: struct %s is not defined as a type" %(tokens2[k+1].value)
  k = k + 1



file2.write("/* Automatically generated */\n#include <stdlib.h>\n#include \"child.h\"\n#include \"ioctls.h\"\n#include \"ioctl_types.h\"\n#include \"maps.h\"\n#include \"random.h\"\n#include \"sanitise.h\"\n#include \"shm.h\"\n#include \"syscall.h\"\n#include \"trinity.h\"\n#include \"fuzz_ioctl_struct.h\"\n\n")

file2.write("static void * recursive_fuzz(enum ioctl_struct_type type, void * local_addr) {\n\nswitch(type) {\n")


for i in struct_list:
  file3.write("STRUCT_" + i + ",\n")

k = 0
for i in type_list:
  file2.write("struct " + i[0] + " *p" + str(k) + ";\n")
  k = k + 1

file2.write("\n\n")

k = 0
for i in type_list:
  
  file2.write("case STRUCT_" + i[0] + ":\n")
  file2.write("if(local_addr != NULL)\n" + "p" + str(k) + " = (struct " + i[0] + " *)local_addr;\nelse\n")
  file2.write("p" + str(k) + " = (struct " + i[0] + " *)get_writable_address(sizeof(struct " + i[0] + "));\n")
  file2.write("if(p" + str(k) + ") {\n")
  ################ PARSING #####################
  t = i[1]
  y=0
  for tt in t:

    if t[y].type == "ENUM":
      file2.write("//enum " + t[y+1].value + ";\n")

    if t[y].type == "STRUCT" and t[y+1].type == "NAME":
      if t[y+3].type == "ARRAY" and t[y+2].type == "NAME":
        for kk in range(0, int(t[y+3].value[1:-1])):
          file2.write("recursive_fuzz(STRUCT_" + t[y+1].value + ", &p" + str(k) + "->" + t[y+2].value + "[" + str(kk) + "]);\n")

      elif t[y+2].type == "NAME":
        file2.write("recursive_fuzz(STRUCT_" + t[y+1].value + ", &p" + str(k) + "->" + t[y+2].value + ");\n")

      elif t[y+2].type == "POINTER":
        file2.write("p" + str(k) + "->" + t[y+2].value[1:] + " = (struct " + t[y+1].value + " *) recursive_fuzz(STRUCT_" + t[y+1].value +", NULL);\n")
        


    if t[y].type == "NAME" and t[y+1].type == "NAME" and t[y+2].type == "END":
      if isPrimitive(t[y].value):
        file2.write("//%s is primitive\n" % (t[y+1].value))
        #print("%s is primitive\n" % (t[y+1]))

    elif t[y].type == "NAME" and t[y+1].type == "POINTER":
      if t[y].value == "void":
        #print("%s is a pointer to %s\n" % (t[y+1], t[y+0]))
        file2.write("p" + str(k) + "->" + t[y+1].value[1:] + " = (void *) get_non_null_address();\n")
      elif isPrimitive(t[y].value):
        file2.write("p" + str(k) + "->" + t[y+1].value[1:] + " = (" + t[y].value + " *) get_writable_address(sizeof(" + t[y].value + "));\n")
      #else:
      #file2.write("p" + str(k) + "->" + t[y+1].value[1:] + " = (" + t[y].value + " *) recursive_fuzz(STRUCT_" + t[y].value +");\n")

    elif t[y].type == "NAME" and t[y+1].type == "NAME" and t[y+2].type == "ARRAY":
      #print("%s is an array of %s of %s elements\n" % (t[y+1], t[y+0], t[y+2].value[1:-1]))
      file2.write("//%s is an array of %s of %s elements\n" % (t[y+1].value, t[y+0].value, t[y+2].value[1:-1]))

    y = y + 1



  ##############################################
  file2.write("return p" + str(k) + ";\n}\nreturn get_non_null_address();")
  file2.write("\n\n\n")
  k = k + 1

file2.write("default:\nreturn get_non_null_address();\n}\n}\n\n")

exit(0)

########################### Creation of syscall_args.h #####################


# Beginning of syscall_args.h
file2.write(start)

# Analyze manual_types

tokens_manual = []
start_address = 0
while True:
  start_address = file0.tell()
  line = file0.readline()
  lexer.input(line)
  while True:
    tok = lexer.token()
    if not tok: break          
    tokens_manual.append(tok)    
    
  if(len(tokens_manual) != 0 and tokens_manual[0].value=="case"):
      break

  # INSERT EOF CHECK

  # analyze declarations
  if(len(tokens_manual) != 0):  
    tok = tokens_manual[0]
    tok2 = tokens_manual[1]
    if((tok.type == "NAME") and (tok2.type == "NAME") and (tokens_manual[2].type == "END")):
      manual_declarations.append([tok.value,tok2.value])
      manual_struct_pointers.append(tok.value[0:len(tok.value)-4])
      structures.append(tok.value[1:len(tok.value)-4])
      # Update syscall_args.h      
      file2.write("MagicSyscallArgTypePtr(" + tok.value + ")\n")
      file2.write("MagicSyscallArgTypeStruct(" + tok.value[1:] + ")\n")
      file2.write("MagicSyscallArgTypePointed(" + tok.value + "," + tok.value[1:] + ")\n\n")
      tokens_manual = []

# Create hash-table for primitive types
for i in primitive:
  file2.write("MagicSyscallArgTypePtr(P" + i[0] + "_WST)\n")
  file2.write("MagicSyscallArgTypePrimitive(" + i[0] + "_WST)\n")
  # Enum types
  if(len(i) == 3):
    file2.write("SyscallArgEnum(" + i[0] + "_WST," + str(i[1]) + "," + str(i[2]) + ")\n")
  file2.write("MagicSyscallArgTypePointed(P" + i[0] + "_WST," + i[0] + "_WST)\n\n")
  

# Create hast-table for struct types
lino = tokens1[0].lineno
if((tokens1.pop(0).type == "TYPEDEF") and (tokens1.pop(0).type == "STRUCT") and (tokens1.pop(0).type == "NAME") and (tokens1.pop(0).type == "OPEN")):

  while (len(tokens1) != 0):
    if(tokens1.pop(0).type == "CLOSE"):
    
      lino = tokens1[0].lineno
      while True: 
        if((tokens1[0].type == "NAME") and (tokens1.pop(1).type == "COMMA") and (tokens1[1].type == "POINTER")): 
          last = tokens1.pop(2).type
          struct = tokens1.pop(0)
          pointer = tokens1.pop(0)
          struct_pointers.append(pointer.value[1:])
          structures.append(struct.value)      

          file2.write("MagicSyscallArgTypePtr(" + pointer.value[1:] + "_WST)\n")
          file2.write("MagicSyscallArgTypeStruct(" + struct.value + "_WST)\n")
          file2.write("MagicSyscallArgTypePointed(" + pointer.value[1:] + "_WST," + struct.value + "_WST)\n\n")                    

          if(last == "END"):
            break
          elif(last != "COMMA"):
            print "Something wrong at line " + str(lino)
            exit()

      else:  
        print "Something wrong at line " + str(lino)
        exit()
          

else: 
  print "Something wrong at line " + str(lino) 
  exit()


# end of the file syscall_args.h
file2.write(end)


################# Creation of recursive_analyze.c ##########################

declarations = []
pointer_declarations = []
global_declarations = []
case_declarations = []
tamplate = ""
pointer = ""

# At the beginning write the begin and the pointers declaration
file3.write(start_recursive)

for p in manual_declarations:
  file3.write(" "*4 + p[0] + " " + p[1] + ";\n")

for p in struct_pointers:
  file3.write(" "*4 + p+"_WST " + lower(p) + ";\n")
file3.write("\n")

# Print the manual tamplates
file0.seek(start_address)

for i in file0.readlines():
  file3.write(" "*4 + i)

file3.write("\n\n")

# Analyze struct_types and generate the tamplates

lino = tokens2[0].lineno
while (len(tokens2) != 0):
  # Analyze the struct and create the tamplate
  if(tokens2.pop(0).type == "OPEN"):
    while (tokens2[0].type != "CLOSE"):
      lino = tokens2[0].lineno
      if((tokens2[0].type == "NAME") and (tokens2[1].type == "NAME") and (tokens2[2].type == "END")):
        type = tokens2.pop(0).value
        name = tokens2.pop(0).value
        tokens2.pop(0)
        # Memoryze pointer and structures declarations
        if((type in struct_pointers) or (type in manual_struct_pointers)):
          pointer_declarations.append([type,name])
        elif (isPrimitive(type)):
          declarations.append([type,name])
        elif (type in structures):
          pass
        else:
          print "Something wrong at line " + str(lino)
          exit()
        global_declarations.append([type,name])

      # Check if the declaration was with an array
      elif(tokens2[0].type == "NAME") and (tokens2[1].type == "NAME"):
        if((tokens2.pop(2).value == "[") and (tokens2[2].type == "NUMBER") and (tokens2.pop(3).value == "]") and (tokens2.pop(3).type == "END")):
          global_declarations.append([tokens2.pop(0).value,tokens2.pop(0).value,tokens2.pop(0).value])
        else:
          print "Something wrong at line " + str(lino)
          exit()


      else:
        print "Something wrong at line " + str(lino)
        exit()

    tokens2.pop(0)
    while True:
      if((tokens2[0].type == "NAME") and (tokens2.pop(1).type == "COMMA") and (tokens2[1].type == "POINTER")):    
        last = tokens2.pop(2).type
        tamplate = tokens2.pop(0).value
        pointer = tokens2.pop(0).value[1:]
        case_declarations.append([tamplate,pointer])
        if(last == "END"):
          break

        elif(last != "COMMA"):
          print "Something wrong at line " + str(lino) 
          exit()     

      else:
        print "Something wrong at line " + str(lino)
        exit()
  
    # Write the template for the struct just analyzed
    for dec in case_declarations:
      file3.write(" "*4 +"//" + upper(dec[0]) + "_WST\n")
      file3.write(" "*4 + "case SyscallArgType_" + dec[0] + "_WST:\n")
    case_declarations = []
    file3.write("\n"+" "*6 + "switch(act) { \n\n")

    # Dump tamplate

    file3.write(" "*8 + "/* Dump tamplate */\n")
    file3.write(" "*8 + "case Action_Dump:\n")
    file3.write(" "*10 + "lastArg = (hvm_address)VmmAlloc(sizeof(" + tamplate + "_WST));\n")
    file3.write(" "*10 + "/* Sanity check: vmmAlloc could be failed */\n"+ " "*10 + "if(lastArg == NULL_VALUE) return;\n\n")
    file3.write(" "*10 + "MmuReadVirtualRegion(context.GuestContext.CR3,addr,(void *)lastArg,sizeof(" + tamplate + "_WST));\n") 
    file3.write(" "*10 + "/* Overwrite the pointer,must point in the structure allocated in the heap */\n")
    file3.write(" "*10 + "MmuReadVirtualRegion(context.GuestContext.CR3,(hvm_address)&lastArg,(void *)arg,sizeof(lastArg));\n")
    if(len(pointer_declarations) != 0):
      file3.write(" "*10 + "p"+lower(tamplate) + " = (" + pointer + "_WST) lastArg;\n")
      for dec in pointer_declarations:
        file3.write(" "*10 + "/* Recursive dump */\n")
        file3.write(" "*10 + "RecursiveDump((hvm_address)&" + "p"+lower(tamplate) + "->" + dec[1] +
                    ",(hvm_address)" + "p"+lower(tamplate) + "->" + dec[1] + ",SyscallArgType_" + dec[0] + "_WST);\n")

    file3.write(" "*10 + "return;\n\n")

    # Fuzz tamplate
    file3.write(" "*8 + "/* Fuzz tamplate */\n")
    file3.write(" "*8 + "case Action_Fuzz:\n")
    file3.write(" "*10 + "p"+lower(tamplate) + " = (" + pointer + "_WST) addr;\n")
    for dec in global_declarations:
      # Skip array
      if(len(dec) == 3):
        continue
      # Pointer to a struct
      if((dec[0] in struct_pointers) or (dec[0] in manual_struct_pointers)):
        file3.write(" "*10 + "MmuReadVirtualRegion(context.GuestContext.CR3,(hvm_address)" + "&p"+lower(tamplate) + "->" + dec[1] + ",(void *)&lastArg,sizeof(" + dec[0]+ "_WST));\n")
        file3.write(" "*10 + "RecursiveFuzz(lastArg,SyscallArgType_" + dec[0] + "_WST);\n")
      # Skip structure inside the structure
      elif(dec[0] in structures ):
        continue
      # Primitive type
      else:
        file3.write(" "*10 + "FuzzerManagerManageArg(SyscallArgType_" + dec[0] + "_WST," + "(hvm_address)&p"+lower(tamplate) + "->" + dec[1]+");\n") 

    file3.write(" "*10 + "return;\n\n")

    # Print tamplate
    file3.write(" "*8 + "/* Print tamplate */\n")
    file3.write(" "*8 + "case Action_Print: {\n")
    for dec in global_declarations:
      if(len(dec) == 3):
         file3.write(" "*10 + "int i,size;\n")
         file3.write(" "*10 + "char tmp[32];\n")
         break

    file3.write(" "*10 + "p"+lower(tamplate) + " = (" + pointer + "_WST) addr;\n")
    file3.write(" "*10 + "PagerAddLine(\"" + tamplate + "_WST:\");\n")
    for dec in global_declarations:
      size = ""     
      # Manage an array
      if(len(dec) == 3):        
        if(str(dec[2]) != "-1"):
          size = str(dec[2])
          file3.write(" "*10 + "size = " + str(dec[2]) +";\n")
        else:
          size = "ANYSIZE" 
          file3.write(" "*10 + "size = sizeof(" + "p"+lower(tamplate) + "->" + dec[1]  + ") / sizeof(" + dec[0] + "_WST);\n")
        file3.write(" "*10 + "PagerAddLine(\"" + dec[0] + " " + dec[1] + "[" + size + "]" + ":\");\n")
        file3.write(" "*10 + "strncpy(string,\"\",100);\n")
        file3.write(" "*10 + "for(i = 0;i<size;i++) {\n")
        file3.write(" "*12 + "vmm_snprintf(tmp,32,\"[%d] %x \",i," + "p"+lower(tamplate) + "->" + dec[1] + "[i]);\n")
        file3.write(" "*12 + "vmm_strncat(string,tmp,32);\n")
        file3.write(" "*12 + "if((size <= BLOCKS || i >= (size - (size % BLOCKS))) && i == size-1) { \n" )
        file3.write(" "*14 + "PagerAddLine(string);\n") 
        file3.write(" "*12 + "}\n")
        file3.write(" "*12 + "else if(i%BLOCKS == BLOCKS-1){ \n")
        file3.write(" "*14 + "PagerAddLine(string);\n")
        file3.write(" "*14 + "strncpy(string,\"\",100);\n")
        file3.write(" "*12 + "}\n")
        file3.write(" "*10 + "}\n")

      # Pointer to a struct
      else:
        if((dec[0] in struct_pointers) or (dec[0] in manual_struct_pointers)):
          file3.write(" "*10 + "vmm_snprintf(string,100,\"" + dec[0] + "_WST " + dec[1] + ":\");\n") 
          file3.write(" "*10 + "PagerAddLine(string);\n")
          file3.write(" "*10 + "RecursivePrint((hvm_address)" + "p"+lower(tamplate) + "->" + dec[1] + ",SyscallArgType_" + dec[0] + "_WST);\n")

        # if it's a structure inside the structure    
        elif(dec[0] in structures ):
          file3.write(" "*10 + "vmm_snprintf(string,100,\"" + dec[0] + "_WST " + dec[1] + ":\");\n")
          file3.write(" "*10 + "PagerAddLine(string);\n")
          file3.write(" "*10 + "RecursivePrint((hvm_address)&p"+lower(tamplate) + "->" + dec[1] + ",SyscallArgType_P" + dec[0] + "_WST);\n")

        # Primitive type
        else:
          file3.write(" "*10 + "vmm_snprintf(string,100,\"" + dec[0] + "_WST " + dec[1] + ": %d\"," + "p"+lower(tamplate) + "->" + dec[1]+");\n")        
          file3.write(" "*10 + "PagerAddLine(string);\n")
    file3.write(" "*10 + "return;\n")
    file3.write(" "*8 + "}\n\n") 

    # Free tamplate
    file3.write(" "*8 + "/* Free tamplate */\n")
    file3.write(" "*8 + "case Action_Free:\n")
    if(len(pointer_declarations) != 0):
      file3.write(" "*10 + "p"+lower(tamplate) + " = (" + pointer + "_WST) addr;\n")
      for dec in pointer_declarations:        
        file3.write(" "*10 + "RecursiveFree((hvm_address)" + "p"+lower(tamplate) + "->" + dec[1] + ",SyscallArgType_" + dec[0] + "_WST);\n")
    file3.write(" "*10 + "VmmFree(addr);\n");
    file3.write(" "*10 + "return;\n\n");   

    # Close the template
    file3.write(" "*6 + "}\n\n\n\n");
     

    declarations = []
    pointer_declarations = []
    global_declarations = []
    tamplate = ""
    pointer = ""

# Write the end of the file
file3.write(end_recursive)

file0.close()
file1.close()
file2.close()
file3.close()


