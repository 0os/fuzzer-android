/***** Automatically generated by gen_recursive.c *********/

#include <stdio.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <libxml/xmlwriter.h>
#include <libxml/encoding.h>
#include <sys/times.h>
#include <sched.h>
#include <linux/kexec.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/vfs.h>
#include <sys/syscall.h>
#include <linux/aio_abi.h>
#include <unistd.h>
#include <utime.h>
#include <dirent.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <poll.h>
#include <sys/epoll.h>
#include <sys/utsname.h>
#ifdef LOLLIPOP
#include <sys/msg.h>
#include <sys/timex.h>
#endif
#include <sys/ipc.h>
#include <linux/shm.h>
#include <linux/futex.h>
#include <linux/fs.h>
#include <linux/sysctl.h>

#include "struct_analyze.h"
#include "syscall.h"
#include "ioctl_types.h"

int nullfd = 0;

void struct_recursive_analyze(void *arg_ptr, bool is_ioctl_call, enum ioctl_struct_type ioctl_struct_type, enum struct_argtype struct_argtype, xmlTextWriterPtr writer) {

if(arg_ptr == NULL)
return;
if(nullfd == 0)
nullfd = open("/dev/random", O_WRONLY);

if(is_ioctl_call == TRUE) {
switch(ioctl_struct_type) {
struct qseecom_register_listener_req *p0;
struct qseecom_send_cmd_req *p1;
struct qseecom_ion_fd_info *p2;
struct qseecom_send_modfd_cmd_req *p3;
struct qseecom_send_resp_req *p4;
struct qseecom_load_img_req *p5;
struct qseecom_set_sb_mem_param_req *p6;
struct qseecom_qseos_version_req *p7;
struct qseecom_qseos_app_load_query *p8;
struct kgsl_devinfo *p9;
struct kgsl_devmemstore *p10;
struct kgsl_shadowprop *p11;
struct kgsl_version *p12;
struct kgsl_ibdesc *p13;
struct kgsl_device_getproperty *p14;
struct kgsl_device_waittimestamp *p15;
struct kgsl_device_waittimestamp_ctxtid *p16;
struct kgsl_ringbuffer_issueibcmds *p17;
struct kgsl_cmdstream_readtimestamp *p18;
struct kgsl_cmdstream_freememontimestamp *p19;
struct kgsl_drawctxt_create *p20;
struct kgsl_map_user_mem *p21;
struct kgsl_cmdstream_readtimestamp_ctxtid *p22;
struct kgsl_cmdstream_freememontimestamp_ctxtid *p23;
struct kgsl_sharedmem_from_pmem *p24;
struct kgsl_sharedmem_free *p25;
struct kgsl_cff_user_event *p26;
struct kgsl_gmem_desc *p27;
struct kgsl_buffer_desc *p28;
struct kgsl_bind_gmem_shadow *p29;
struct kgsl_sharedmem_from_vmalloc *p30;
struct kgsl_drawctxt_set_bin_base_offset *p31;
struct kgsl_cmdwindow_write *p32;
struct kgsl_cff_syncmem *p33;
struct kgsl_timestamp_event *p34;
struct kgsl_timestamp_event_genlock *p35;
struct kgsl_timestamp_event_fence *p36;
struct kgsl_gpumem_alloc_id *p37;
struct kgsl_gpumem_free_id *p38;
struct kgsl_gpumem_get_info *p39;
struct kgsl_gpumem_sync_cache *p40;
struct kgsl_perfcounter_get *p41;
struct kgsl_perfcounter_put *p42;
struct kgsl_perfcounter_query *p43;
struct kgsl_perfcounter_read_group *p44;
struct kgsl_perfcounter_read *p45;
struct kgsl_drawctxt_destroy *p46;
struct kgsl_gpumem_alloc *p47;
case STRUCT_undefined:

return;

case STRUCT_qseecom_register_listener_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_register_listener_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_register_listener_req", "unmapped");
return;
 }

p0 = (struct qseecom_register_listener_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_register_listener_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p0 , 0, sizeof(struct qseecom_register_listener_req));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_send_cmd_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_send_cmd_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_send_cmd_req", "unmapped");
return;
 }

p1 = (struct qseecom_send_cmd_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_send_cmd_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p1 , 0, sizeof(struct qseecom_send_cmd_req));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p1->cmd_req_buf), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_cmd_req_buf");
xmlTextWriterWriteBase64(writer, (char *) (p1->cmd_req_buf), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_cmd_req_buf", "unmapped");
// void pointer
if(write(nullfd, (void *)(p1->resp_buf), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_resp_buf");
xmlTextWriterWriteBase64(writer, (char *) (p1->resp_buf), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_resp_buf", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_ion_fd_info:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_ion_fd_info)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_ion_fd_info", "unmapped");
return;
 }

p2 = (struct qseecom_ion_fd_info *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_ion_fd_info");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p2 , 0, sizeof(struct qseecom_ion_fd_info));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_send_modfd_cmd_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_send_modfd_cmd_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_send_modfd_cmd_req", "unmapped");
return;
 }

p3 = (struct qseecom_send_modfd_cmd_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_send_modfd_cmd_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p3 , 0, sizeof(struct qseecom_send_modfd_cmd_req));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p3->cmd_req_buf), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_cmd_req_buf");
xmlTextWriterWriteBase64(writer, (char *) (p3->cmd_req_buf), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_cmd_req_buf", "unmapped");
// void pointer
if(write(nullfd, (void *)(p3->resp_buf), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_resp_buf");
xmlTextWriterWriteBase64(writer, (char *) (p3->resp_buf), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_resp_buf", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_send_resp_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_send_resp_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_send_resp_req", "unmapped");
return;
 }

p4 = (struct qseecom_send_resp_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_send_resp_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p4 , 0, sizeof(struct qseecom_send_resp_req));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p4->resp_buf), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_resp_buf");
xmlTextWriterWriteBase64(writer, (char *) (p4->resp_buf), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_resp_buf", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_load_img_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_load_img_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_load_img_req", "unmapped");
return;
 }

p5 = (struct qseecom_load_img_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_load_img_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p5 , 0, sizeof(struct qseecom_load_img_req));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_set_sb_mem_param_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_set_sb_mem_param_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_set_sb_mem_param_req", "unmapped");
return;
 }

p6 = (struct qseecom_set_sb_mem_param_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_set_sb_mem_param_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p6 , 0, sizeof(struct qseecom_set_sb_mem_param_req));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_qseos_version_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_qseos_version_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_qseos_version_req", "unmapped");
return;
 }

p7 = (struct qseecom_qseos_version_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_qseos_version_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p7 , 0, sizeof(struct qseecom_qseos_version_req));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_qseos_app_load_query:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_qseos_app_load_query)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_qseos_app_load_query", "unmapped");
return;
 }

p8 = (struct qseecom_qseos_app_load_query *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_qseos_app_load_query");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p8 , 0, sizeof(struct qseecom_qseos_app_load_query));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_devinfo:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_devinfo)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_devinfo", "unmapped");
return;
 }

p9 = (struct kgsl_devinfo *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_devinfo");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p9 , 0, sizeof(struct kgsl_devinfo));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_devmemstore:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_devmemstore)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_devmemstore", "unmapped");
return;
 }

p10 = (struct kgsl_devmemstore *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_devmemstore");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p10 , 0, sizeof(struct kgsl_devmemstore));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_shadowprop:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_shadowprop)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_shadowprop", "unmapped");
return;
 }

p11 = (struct kgsl_shadowprop *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_shadowprop");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p11 , 0, sizeof(struct kgsl_shadowprop));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_version:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_version)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_version", "unmapped");
return;
 }

p12 = (struct kgsl_version *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_version");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p12 , 0, sizeof(struct kgsl_version));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_ibdesc:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_ibdesc)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_ibdesc", "unmapped");
return;
 }

p13 = (struct kgsl_ibdesc *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_ibdesc");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p13 , 0, sizeof(struct kgsl_ibdesc));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p13->hostptr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_hostptr");
xmlTextWriterWriteBase64(writer, (char *) (p13->hostptr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_hostptr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_device_getproperty:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_device_getproperty)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_device_getproperty", "unmapped");
return;
 }

p14 = (struct kgsl_device_getproperty *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_device_getproperty");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p14 , 0, sizeof(struct kgsl_device_getproperty));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p14->value), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_value");
xmlTextWriterWriteBase64(writer, (char *) (p14->value), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_value", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_device_waittimestamp:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_device_waittimestamp)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_device_waittimestamp", "unmapped");
return;
 }

p15 = (struct kgsl_device_waittimestamp *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_device_waittimestamp");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p15 , 0, sizeof(struct kgsl_device_waittimestamp));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_device_waittimestamp_ctxtid:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_device_waittimestamp_ctxtid)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_device_waittimestamp_ctxtid", "unmapped");
return;
 }

p16 = (struct kgsl_device_waittimestamp_ctxtid *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_device_waittimestamp_ctxtid");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p16 , 0, sizeof(struct kgsl_device_waittimestamp_ctxtid));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_ringbuffer_issueibcmds:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_ringbuffer_issueibcmds)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_ringbuffer_issueibcmds", "unmapped");
return;
 }

p17 = (struct kgsl_ringbuffer_issueibcmds *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_ringbuffer_issueibcmds");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p17 , 0, sizeof(struct kgsl_ringbuffer_issueibcmds));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p17->ibdesc_addr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_ibdesc_addr");
xmlTextWriterWriteBase64(writer, (char *) (p17->ibdesc_addr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_ibdesc_addr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cmdstream_readtimestamp:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cmdstream_readtimestamp)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cmdstream_readtimestamp", "unmapped");
return;
 }

p18 = (struct kgsl_cmdstream_readtimestamp *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cmdstream_readtimestamp");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p18 , 0, sizeof(struct kgsl_cmdstream_readtimestamp));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cmdstream_freememontimestamp:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cmdstream_freememontimestamp)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cmdstream_freememontimestamp", "unmapped");
return;
 }

p19 = (struct kgsl_cmdstream_freememontimestamp *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cmdstream_freememontimestamp");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p19 , 0, sizeof(struct kgsl_cmdstream_freememontimestamp));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p19->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p19->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_drawctxt_create:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_drawctxt_create)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_drawctxt_create", "unmapped");
return;
 }

p20 = (struct kgsl_drawctxt_create *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_drawctxt_create");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p20 , 0, sizeof(struct kgsl_drawctxt_create));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_map_user_mem:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_map_user_mem)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_map_user_mem", "unmapped");
return;
 }

p21 = (struct kgsl_map_user_mem *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_map_user_mem");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p21 , 0, sizeof(struct kgsl_map_user_mem));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p21->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p21->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
// void pointer
if(write(nullfd, (void *)(p21->hostptr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_hostptr");
xmlTextWriterWriteBase64(writer, (char *) (p21->hostptr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_hostptr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cmdstream_readtimestamp_ctxtid:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cmdstream_readtimestamp_ctxtid)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cmdstream_readtimestamp_ctxtid", "unmapped");
return;
 }

p22 = (struct kgsl_cmdstream_readtimestamp_ctxtid *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cmdstream_readtimestamp_ctxtid");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p22 , 0, sizeof(struct kgsl_cmdstream_readtimestamp_ctxtid));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cmdstream_freememontimestamp_ctxtid:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cmdstream_freememontimestamp_ctxtid)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cmdstream_freememontimestamp_ctxtid", "unmapped");
return;
 }

p23 = (struct kgsl_cmdstream_freememontimestamp_ctxtid *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cmdstream_freememontimestamp_ctxtid");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p23 , 0, sizeof(struct kgsl_cmdstream_freememontimestamp_ctxtid));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p23->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p23->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_sharedmem_from_pmem:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_sharedmem_from_pmem)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_sharedmem_from_pmem", "unmapped");
return;
 }

p24 = (struct kgsl_sharedmem_from_pmem *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_sharedmem_from_pmem");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p24 , 0, sizeof(struct kgsl_sharedmem_from_pmem));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p24->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p24->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_sharedmem_free:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_sharedmem_free)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_sharedmem_free", "unmapped");
return;
 }

p25 = (struct kgsl_sharedmem_free *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_sharedmem_free");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p25 , 0, sizeof(struct kgsl_sharedmem_free));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p25->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p25->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cff_user_event:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cff_user_event)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cff_user_event", "unmapped");
return;
 }

p26 = (struct kgsl_cff_user_event *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cff_user_event");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p26 , 0, sizeof(struct kgsl_cff_user_event));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gmem_desc:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gmem_desc)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gmem_desc", "unmapped");
return;
 }

p27 = (struct kgsl_gmem_desc *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gmem_desc");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p27 , 0, sizeof(struct kgsl_gmem_desc));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_buffer_desc:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_buffer_desc)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_buffer_desc", "unmapped");
return;
 }

p28 = (struct kgsl_buffer_desc *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_buffer_desc");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p28 , 0, sizeof(struct kgsl_buffer_desc));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p28->hostptr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_hostptr");
xmlTextWriterWriteBase64(writer, (char *) (p28->hostptr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_hostptr", "unmapped");
// void pointer
if(write(nullfd, (void *)(p28->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p28->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_bind_gmem_shadow:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_bind_gmem_shadow)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_bind_gmem_shadow", "unmapped");
return;
 }

p29 = (struct kgsl_bind_gmem_shadow *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_bind_gmem_shadow");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p29 , 0, sizeof(struct kgsl_bind_gmem_shadow));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_sharedmem_from_vmalloc:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_sharedmem_from_vmalloc)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_sharedmem_from_vmalloc", "unmapped");
return;
 }

p30 = (struct kgsl_sharedmem_from_vmalloc *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_sharedmem_from_vmalloc");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p30 , 0, sizeof(struct kgsl_sharedmem_from_vmalloc));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p30->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p30->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
// void pointer
if(write(nullfd, (void *)(p30->hostptr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_hostptr");
xmlTextWriterWriteBase64(writer, (char *) (p30->hostptr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_hostptr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_drawctxt_set_bin_base_offset:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_drawctxt_set_bin_base_offset)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_drawctxt_set_bin_base_offset", "unmapped");
return;
 }

p31 = (struct kgsl_drawctxt_set_bin_base_offset *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_drawctxt_set_bin_base_offset");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p31 , 0, sizeof(struct kgsl_drawctxt_set_bin_base_offset));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cmdwindow_write:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cmdwindow_write)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cmdwindow_write", "unmapped");
return;
 }

p32 = (struct kgsl_cmdwindow_write *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cmdwindow_write");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p32 , 0, sizeof(struct kgsl_cmdwindow_write));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p32->addr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_addr");
xmlTextWriterWriteBase64(writer, (char *) (p32->addr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_addr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cff_syncmem:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cff_syncmem)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cff_syncmem", "unmapped");
return;
 }

p33 = (struct kgsl_cff_syncmem *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cff_syncmem");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p33 , 0, sizeof(struct kgsl_cff_syncmem));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p33->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p33->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_timestamp_event:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_timestamp_event)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_timestamp_event", "unmapped");
return;
 }

p34 = (struct kgsl_timestamp_event *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_timestamp_event");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p34 , 0, sizeof(struct kgsl_timestamp_event));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p34->priv), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_priv");
xmlTextWriterWriteBase64(writer, (char *) (p34->priv), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_priv", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_timestamp_event_genlock:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_timestamp_event_genlock)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_timestamp_event_genlock", "unmapped");
return;
 }

p35 = (struct kgsl_timestamp_event_genlock *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_timestamp_event_genlock");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p35 , 0, sizeof(struct kgsl_timestamp_event_genlock));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_timestamp_event_fence:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_timestamp_event_fence)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_timestamp_event_fence", "unmapped");
return;
 }

p36 = (struct kgsl_timestamp_event_fence *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_timestamp_event_fence");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p36 , 0, sizeof(struct kgsl_timestamp_event_fence));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gpumem_alloc_id:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gpumem_alloc_id)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gpumem_alloc_id", "unmapped");
return;
 }

p37 = (struct kgsl_gpumem_alloc_id *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gpumem_alloc_id");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p37 , 0, sizeof(struct kgsl_gpumem_alloc_id));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p37->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p37->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gpumem_free_id:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gpumem_free_id)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gpumem_free_id", "unmapped");
return;
 }

p38 = (struct kgsl_gpumem_free_id *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gpumem_free_id");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p38 , 0, sizeof(struct kgsl_gpumem_free_id));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gpumem_get_info:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gpumem_get_info)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gpumem_get_info", "unmapped");
return;
 }

p39 = (struct kgsl_gpumem_get_info *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gpumem_get_info");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p39 , 0, sizeof(struct kgsl_gpumem_get_info));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p39->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p39->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
// void pointer
if(write(nullfd, (void *)(p39->useraddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_useraddr");
xmlTextWriterWriteBase64(writer, (char *) (p39->useraddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_useraddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gpumem_sync_cache:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gpumem_sync_cache)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gpumem_sync_cache", "unmapped");
return;
 }

p40 = (struct kgsl_gpumem_sync_cache *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gpumem_sync_cache");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p40 , 0, sizeof(struct kgsl_gpumem_sync_cache));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p40->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p40->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_perfcounter_get:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_perfcounter_get)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_perfcounter_get", "unmapped");
return;
 }

p41 = (struct kgsl_perfcounter_get *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_perfcounter_get");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p41 , 0, sizeof(struct kgsl_perfcounter_get));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_perfcounter_put:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_perfcounter_put)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_perfcounter_put", "unmapped");
return;
 }

p42 = (struct kgsl_perfcounter_put *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_perfcounter_put");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p42 , 0, sizeof(struct kgsl_perfcounter_put));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_perfcounter_query:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_perfcounter_query)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_perfcounter_query", "unmapped");
return;
 }

p43 = (struct kgsl_perfcounter_query *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_perfcounter_query");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p43 , 0, sizeof(struct kgsl_perfcounter_query));
xmlTextWriterEndElement(writer);

// pointer to primitive
if(write(nullfd, (void *)(p43->countables), 4) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_countables");
xmlTextWriterWriteBase64(writer, (char *) (p43->countables), 0, 4);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_countables", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_perfcounter_read_group:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_perfcounter_read_group)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_perfcounter_read_group", "unmapped");
return;
 }

p44 = (struct kgsl_perfcounter_read_group *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_perfcounter_read_group");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p44 , 0, sizeof(struct kgsl_perfcounter_read_group));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_perfcounter_read:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_perfcounter_read)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_perfcounter_read", "unmapped");
return;
 }

p45 = (struct kgsl_perfcounter_read *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_perfcounter_read");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p45 , 0, sizeof(struct kgsl_perfcounter_read));
xmlTextWriterEndElement(writer);

// Pointer to struct kgsl_perfcounter_read_group
struct_recursive_analyze((void *)(p45->reads), TRUE, STRUCT_kgsl_perfcounter_read_group, 0, writer);
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_drawctxt_destroy:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_drawctxt_destroy)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_drawctxt_destroy", "unmapped");
return;
 }

p46 = (struct kgsl_drawctxt_destroy *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_drawctxt_destroy");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p46 , 0, sizeof(struct kgsl_drawctxt_destroy));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gpumem_alloc:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gpumem_alloc)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gpumem_alloc", "unmapped");
return;
 }

p47 = (struct kgsl_gpumem_alloc *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gpumem_alloc");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p47 , 0, sizeof(struct kgsl_gpumem_alloc));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p47->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p47->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;



}
}
}
